# 一 机器学习介绍

#### 1.定义

 机器学习是使用算法分析数据，**从数据中学习**，然后对新数据做出确定或预测的做法。

#### ==**2.从数据中学习**==

* 通过机器学习，机器不是使用一组特定的指令手动编写代码来完成特定任务，而是使用**数据和算法进行训练**，使其能够在**没有明确告知如何执行任务**的情况下执行任务。

  

# 二 深度学习解释

#### 1.定义

深度学习是机器学习的一个子领域，它使用**受大脑神经网络结构和功能启发**的算法。

#### 2.测验

<u>*“模型从已标记的数据中学习并进行推理”*</u> 这句话最具体地归类为==**监督学习**==

# 三 人工神经网络(ANN)

#### 1.前提准备

* 经常与***net  网  neural net  神经网络   model  型***交换使用
* ANN由**神经元**构成，ANN中的神经元又叫做**层**，层在ANN（除去输入和输出之外的所以层)叫做**隐藏层**，含有**多个**隐藏层在ANN中称之为**深度ANN**

#### 2.定义

人工神经网络是一种**计算系统**，它由一组称为**神经元（节点）**的连接单元组成，这些单元被组织成我们所说的层。

#### **3.节点**

* Input layer （输入层） - 输入数据的**每个**组件**对应一个**节点。       ex:2个

* Hidden layer==**s**== (隐藏层） - 为每个隐藏层**任意选择**的节点数。        ex:3个

* Output layer （输出层） - **每个**可能的所需输出**对应一个**节点。    ex:2个

  ![690d642a675a138adfe1a435d03809a](C:/Users/xxyyll/Documents/WeChat Files/wxid_zi6gt18kaejk22/FileStorage/Temp/690d642a675a138adfe1a435d03809a.png)

  1.比如这个图中，输入输入层中有两个节点，这告诉我们这个网络的每个输入都必须有两个维度
  2.由于这个网络在输出层中有两个节点，这告诉我们通过网络向前传递（从左到右）的每个输入都有两个可能的输出

#### 4.可视化ANN（Keras sequential model）

```python
from keras.models import Sequential
from keras.layers import Dense, Activation  # 导入所需的Kears类

///一种写法
layers = [ 
    # dense表示层类型为“密集”，并且 dense 层的每个输出都是使用该层的每个输入计算的。
    Dense(units=3, input_shape=(2,), activation='relu'),  
    # 输入 shape 参数 input_shape=（2） 告诉我们输入层有多少个神经元
    Dense(units=2, activation='softmax')
]
model = Sequential(layers) # 创建model的实例，设置等于Sequential对象

///另一种写法
model = Sequential()
model.add(Dense(units=3, input_shape=(2,)))
model.add(Activation('relu'))
```

#### 5.测验

* 在神经网络编程中，激活函数是通常遵循密集层的==***非线性***==函数

# 四  神经网络的层

#### 1.图层类型

* Dense (or fully connected) layers  密集（或完全连接）层     （将每个输入完全连接到其层中的每个输出
* Convolutional layers  卷积层     （处理数据的模型）
* Pooling layers  池化层
* Recurrent layers  复发层
* Normalization layers  归一化层

#### 2.权重

* 每个权重表示**两个节点**之间的**连接强度**。当网络在输入层的给定节点收到输入时，此输入将通过连接传递到下一个节点，并且输入将==乘以分配给该连接的权重==。
* ==**节点输出 = 激活（输入的加权和）**==，激活函数对给定的==**和**==执行某种类型的转换，将总和转换为通常介于某个下限和某个上限之间的数字，这种转换一般是**<u>非线性转</u>换**

#### 3.正向传递

对于数据集中的给定样本，从**输入层到输出层的整个过程**称为通过网络的正向传递

#### 4.测验

* 神经网络输入层中的每个节点都表示输入数据的单个特征
* 层可以作为<u>**列表**</u>传递到 Keras `Sequential` 模型中

# 五 神经网络中的激活函数

#### 1.定义

在人工神经网络中，激活函数是将节点的**输入映射**到其**相应输出**的函数。

#### 2.作用

具有非线性激活函数使我们的神经网络能够计算**任意复杂的函数**

# 六 训练神经网络

#### 1.定义

训练模型以尝试解决一个优化问题，找到最准确地将输入数据映射到正确输出类的权重

通过我们的模型传递所有数据后，我们将继续一遍又一遍地传递相同的数据。这种通过网络**重复发送相同数据**的过程被认为是 ***培训*** 。

#### **2** 优化算法

**SGD（随机梯度下降）**是最广为人知的优化器，使==*损失函数（loss函数）*==尽可能接近其最小值的方式更新模型的权重，**损失**是网络对<u>图像的预测</u>与<u>图像的真实标签之间</u>的误差或差异

# 七 神经网络学习如何解释

#### 1.epoch

纪元是指在训练期间将**整个**数据集**单次**传递到网络。

#### 2.权重更新

==新权重=旧权重-（学习速率*梯度）==

* 注意，当计算损失函数的梯度时，每个权重的梯度值会有所**不同**，因为梯度是相对于每个权重计算的

#### 3.代码训练

```python
import keras
from keras.models import Sequential
from keras.layers import Activation
from keras.layers.core import Dense
from keras.optimizers import Adam
from keras.metrics import categorical_crossentropy    #导入所需的类

# 定义模型
model = Sequential([
    Dense(units=16, input_shape=(1,), activation='relu'),
    Dense(units=32, activation='relu'),
    Dense(units=2, activation='sigmoid')  #sigmoid类型将输出压缩的(0，1)间，适合二分类问题
])

model.compile(
    optimizer=Adam(learning_rate=0.0001),   
    # Adam是SGD的一个变体，结合动量与自适应学习率，比传统SGD收敛更快	
    loss='sparse_categorical_crossentropy', 
    metrics=['accuracy']
)
model.fit(
    x=scaled_train_samples,  # 由训练样本组成的 numpy 数组
    y=train_labels,  # 是一个 numpy 数组，由训练样本的相应标签组成
    batch_size=10,   # 指定一次应向模型发送多少个训练样本
    epochs=20,       # 表示完整的训练集（所有样本）将总共传递给模型 20 次
    shuffle=True,    # 表示在将数据传递给模型之前，先打乱顺序，防止记忆样本顺序
    verbose=2        # 表示在模型训练时我们将看到多少日志记录
)
```

# 八 神经网络中的损失函数

#### 1.损失函数

在训练过程中的每个 epoch 结束时，将使用网络的<u>输出预测</u>和<u>相应输入的真实标签</u>来计算损失，对每个 output 执行此过程。对于每个 epoch，误差在所有**单独的 output 中累积**

#### 2.MSE

![9080e487f51b28d38b49524d39fc4e1](C:/Users/xxyyll/Documents/WeChat Files/wxid_zi6gt18kaejk22/FileStorage/Temp/9080e487f51b28d38b49524d39fc4e1.png)

我们实际处理每个误差的实现将取决于我们使用的**给定损失函数的算法**

# 九 学习率

#### 1.学习率

* 从概念上讲，我们可以将模型的学习率视为 ***步长*** 
* 学习率是一个很小的数字，通常在 `0.01` 到 `0.0001` 之间，但实际值可能会有所不同

#### 2.代码实现

```python
model.optimizer.learning_rate = 0.01  # 编译完模型后，可以这样设置
```

```py
model.compile(
    optimizer=Adam(learning_rate=0.0001),   
    # Adam是SGD的一个变体，结合动量与自适应学习率，比传统SGD收敛更快	
    loss='sparse_categorical_crossentropy', 
    metrics=['accuracy']
)
```

#### 3.测验

* **超参数：**是在开始学习过程之前设置值的参数，而不是训练后得到的参数。而学习率属于人为提前设定好的，所以学习率是一个超参数
* 在代码实现中，通常需要具有学习率的对象是**优化**

# 十 训练，测试和验证集

#### 1.训练集

* 用于模型参数学习和特征提取的核心数据集，通过**最小化损失函数**调整模型内部参数（如神经网络权重）
* 用于**训练模型**。训练的目标是使*<u>模型适应训练集，同时仍泛化到看不见的数据</u>*

#### 2.验证集

* 验证集是一组**独立于**训练集的数据，在训练过程中用于模型选择和超参数调优的**独立数据集**（如学习率、网络层数等）
* 我们需要验证集的主要原因之一是确保我们的模型**不会过度拟合训练集中的数据**，过拟合的想法是，我们的模型变得非常擅长对训练集中的数据进行分类，但它<u>无法对未经过训练的数据进行泛化和准确分类</u> 
* 验证集允许我们查看模型在训练期间的**泛化程度**

#### 3.测试集

* 模型训练完成后用于**最终性能评估**的独立数据集，<u>是一组数据</u>，要求与训练集、验证集**完全独立**
* 测试集<u>***不应该被标记***</u>，验证集，训练集需要标记才能看到指标，但是测试集不用
* 用于在部署到生产环境之前测试模型的最终泛化能力。

#### 4.测验

* 
